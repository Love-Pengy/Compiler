#ifndef TCLEXER_H
    #include "../include/TClexer.h"
#endif
#ifndef TCTOKEN_H
    #include "../include/TCtoken.h"
#endif
#ifndef STDLIB_H
    #include <stdlib.h>
#endif
#ifndef STDIO_H
    #include <stdio.h>
#endif
#ifndef STRING_H
    #include <string.h>
#endif
#ifndef CTYPE_H
    #include <ctype.h>
#endif

int LEXERDEBUG = 0;
static char* currentLine; 
static char* currentToken = "";
/*
* STRING
* RELOP
* ADDOP
* MULOP
*   *
*   /
*   %
*   &&
* ASSIGNOP
*/
static const char *keywordLUT[] = {
    "int", "char", "return", "if", "else", 
    "for", "do", "while", "switch", "case", 
    "default", "write", "read", "continue", 
    "break", "newline"
};

int checkLUT(char* inString){
    for(int i = 0; i < (sizeof(keywordLUT)/sizeof(keywordLUT[0])); i++){
        if(!strcmp(inString, keywordLUT[i])){
            return(1);
        }
    }
    return(0);
}


//gets raw string
char *getLine(FILE* fptr){
    char *output = malloc(sizeof(char) * 500);
    return(fgets(output, 500, fptr));
}

//get the sequence of characters that we're lookiung for (or error ig)
char *getLexeme(FILE* fp){
    char *lexeme = malloc(sizeof(char) * 550);
    if(strlen(currentToken) == 0){
        currentLine = getLine(fp);
        if(!currentLine){
            return("<EOF>, \"EOF\"");
        }
        else{
            currentToken = strtok(strdup(currentLine), " "); 
        }
    }
    else{
        if(!(currentToken = strtok(NULL, " "))){
            currentLine = malloc(sizeof(char) * 501);
            if(!(currentLine = getLine(fp))){
                return("<EOF>, \"EOF\"");
            }
        }    
    }

    if(LEXERDEBUG){
        printf(".%s.\n", currentToken);
    }
    if(!strcmp(currentToken, ":")){
        strcat(lexeme, "<COLON>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, "!")){
        strcat(lexeme, "<NOT>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, ";")){
        strcat(lexeme, "<SEMICOLON>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, ",")){
        strcat(lexeme, "<COMMA>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, "]")){
        strcat(lexeme, "<RBRACKET>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, "[")){
        strcat(lexeme, "<LBRACKET>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, "}")){
        strcat(lexeme, "<RCURLY>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, "{")){
        strcat(lexeme, "<LCURLY>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, ")")){
        strcat(lexeme, "<RPAREN>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, "/") || !strcmp(currentToken, "%") || !strcmp(currentToken, "&&")){
        strcat(lexeme, "<MULOP>, \"");
        strcat(lexeme, currentToken);
        strcat(lexeme, "\"");
        return(lexeme);
    }
    else if(!strcmp(currentToken, "/*") || !strcmp(currentToken, "*/")){
        return("COMMENT1");
    }
    else if(!strcmp(currentToken, "//")){   
        return("COMMENT2");
    }
    //KEYWOD & ID
    else if(isalpha(currentToken[0])){
        for(int i = 0; i < strlen(currentToken); i++){
            if(!isalnum(currentToken[i])){
                printf("Invalid currentToken: %s\n", currentToken); 
                exit(EXIT_FAILURE);
            }
        }
        if(checkLUT(currentToken)){
            return("KEYWORD");
        }
        else{
            return("ID");
        }
    }
    //NUMBER
    else if(isdigit(currentToken[0])){
        int fraction = 0; 
        int exponent = 0;
        for(int i = 0; i < strlen(currentToken); i++){
            if(isdigit(currentToken[i])){
                continue;
            }
            else{
                if((currentToken[i] == '+') || (currentToken[i] == '-')){
                    if(!exponent){
                        printf("+ or - without exponent specifier");
                        exit(EXIT_FAILURE);
                    }
                }
                if(currentToken[i] == '.'){
                    if((!fraction) && (!exponent)){
                        fraction = 1;
                    }
                    else{
                        printf("Invalid Number of Float Identifiers\n");
                        exit(EXIT_FAILURE);
                    }
                }
                if(currentToken[i] == 'E'){
                    if(!exponent){
                        exponent = 1;
                    }
                    else{
                        printf("Invalid Number of Exponent Identifiers\n");
                        exit(EXIT_FAILURE);
                    }
                }
            }
        }
        return("NUMBER");   
    }
    //CHARLITERAL
    else if(currentToken[0] == '\''){
        if(currentToken[1] == '\''){
            return("CHARLITERAL");
        }
        if(isalpha(currentToken[1])){
            if(currentToken[2] == '\''){
                return("CHARLITERAL");
            }
        }
        printf("Invalid Char Specification");
        exit(EXIT_FAILURE);
    }

    /*
    //STRING
    else if(sequence[0] == '\"'){
        for(int i = 0; i < strlen(sequence); i++){
            if(
            if(isalpha(sequence[i])){
                continue;
            }
        }
    }
    */
    else{
        return("NOT IMPLEMENTED YET");
    }

    


}

int getLineNum();
int getPos();

